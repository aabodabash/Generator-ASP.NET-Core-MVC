<#@ include file = "..\..\Base\Templates\Include.tt" #>
<#
    var model = (EntityInfo)Model;
    var lastType = ModelPropertiesTypes.LastOrDefault();

    var keyProperty = model
        .GetProperties()
        .FirstOrDefault(p => p.IsKey);

    var keyType = keyProperty != null ?
        keyProperty
            .ModelProperty?
            .Substring(
                0,
                keyProperty.ModelProperty.IndexOf(".")) :
        "";

    if (string.IsNullOrEmpty(keyType))
    {
        keyType = model
            .GetEntityDirectReferences()
            .FirstOrDefault()?
            .Id
            .CSharpType();
    }

    var datamodelsNamespace = $"{ApplicationId}.Backend.DataModels";
#>
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using <#= datamodelsNamespace #>;

namespace <#= ApplicationId #>.Backend.<#= ViewModelNamespace #>
{
    public partial class <#= model.Id.ToPascalCase() #><#= model.BaseEntity != null ? $" : {model.BaseEntity.Id.ToPascalCase()}" : "" #>
    {
        public <#= model.Id.ToPascalCase() #>() <#= model.BaseEntity != null ? " : base()" : "" #>
        {
<#
    if (model.References != null
        && model.References.Count() > 0)
    {
        foreach (var reference in model.References)
        {
            var currentReference = reference.Id;
            var referenceName = currentReference.ToPascalCase();
            var type = $"{datamodelsNamespace}.{reference.Type}";

            if (reference.IsCollection)
            {
#>
            <#= referenceName #> = new HashSet<<#= type #>>();
<#
            }
            else
            {
#>
            <#= referenceName #> = new <#= type #>();
<#
            }
        }
    }
#>
        }
<#
    if (model.Properties != null)
    {
        foreach (var prop in model.Properties)
        {
            var propertyId = prop.Id.ToPascalCase();
#>

        public <#= prop.CSharpType() #><#= prop.IsNullable? "?" : "" #> <#= propertyId #> { get; set; }
<#
        }
    }

    if (model.References !=null
        && model.References.Count() > 0)
    {
        foreach (var reference in model.References)
        {
            var currentReference = reference.Id;
            var referenceName = currentReference.ToPascalCase();
            var type = $"{datamodelsNamespace}.{reference.Type}";
            var fieldName = reference.Id.ToCamelCase();

            if (reference.IsCollection)
            {
#>

        private HashSet<<#= type #>> _<#= fieldName #>;

        private HashSet<<#= type #>> <#= referenceName #>
        {
            get
            {
                return _<#= fieldName #> ??
                    (_<#= fieldName #> = new HashSet<<#= type #>>());
            }
            set
            {
                _<#= fieldName #> = value;
            }
        }
<#
            }
            else
            {
#>

        private <#= type #> _<#= fieldName #>;

        public virtual <#= reference.Type #> <#= referenceName #>
        {
            get
            {
                return _<#= fieldName #>;
            }
            set
            {
                _<#= fieldName #> = value;
            }
        }
<#
            }
        }
    }

    if (model.BaseEntity == null)
    {
#>

        [Timestamp]
        public byte[] RawVersion { get; set; }
<#
    }

    var isReferencedTypes = ModelPropertiesTypes.Count > 0;
#>

        public <#= model.Id.ToPascalCase() #> ConvertFromModel(<#= isReferencedTypes ? "" : ")" #>
<#
    if (isReferencedTypes)
    {
        foreach (var referencedType in ModelPropertiesTypes.Keys)
        {
            var parameterName = referencedType.ToCamelCase();

            var modelReference = model
                .References
                .FirstOrDefault(r =>
                    r.Type == referencedType);

            var parameterType =
                modelReference != null
                && modelReference.IsCollection ?
                    $"HashSet<{referencedType}>" :
                    referencedType;

            parameterType = $"{datamodelsNamespace}.{parameterType}";
#>
            <#= parameterType #> <#= parameterName #><#= lastType.Key != referencedType ? "," : ")" #>
<#
        }
    }
#>
        {
<#
    if (model.GetProperties() != null)
    {
        foreach (var prop in model.GetProperties())
        {
            if (!string.IsNullOrEmpty(prop.ModelProperty))
            {
                var modelProperty = prop
                    .ModelProperty
                    .Split('.');

                var parameter = $"{modelProperty[0].ToCamelCase()}.{modelProperty[1].ToPascalCase()}";

                var property = prop.Id.ToPascalCase();
#>
            <#= property #> = <#= parameter #>;
<#
            }
        }
    }

    foreach (var reference in model.References)
    {
        var currentReference = ModelPropertiesTypes
            .FirstOrDefault(r =>
                r.Key == reference.Type);

        var parameterName = currentReference.Key.ToCamelCase();

        var fieldName = reference.Id.ToCamelCase();
#>
            _<#= fieldName #> = <#= parameterName #>;
<#
    }
#>

            return this;
        }

<#
    if (ModelPropertiesTypes != null)
    {
        foreach (var refType in ModelPropertiesTypes)
        {
            var currentReferenceType = model
                .References
                .FirstOrDefault(r =>
                    r.Type == refType.Key);

            var type =
                currentReferenceType != null
                && currentReferenceType.IsCollection ?
                    $"HashSet<{refType.Key}>" :
                    refType.Key;

            type = $"{datamodelsNamespace}.{type}";
#>
        public <#= type #> Get<#= refType.Key #>FromViewModel()
        {
<#
            if (model.References?.FirstOrDefault(r => r.Type == refType.Key) != null)
            {
                var fieldName = refType.Key.ToCamelCase();
#>
            return this._<#= fieldName #>;
<#
            }
            else
            {
#>
            var model = new <#= type #>();
<#
                foreach (var prop in model.GetProperties())
                {
                    if (!string.IsNullOrEmpty(prop.ModelProperty)
                        && prop.ModelProperty.StartsWith($"{refType.Key}."))
                    {
                        var propertyName = prop
                            .ModelProperty?
                            .Split('.')
                            .Last()
                            .ToPascalCase();

                        var property = prop.Id.ToPascalCase();
#>
            model.<#= propertyName #> = <#= property #>;
<#
                    }
                }
#>

            return model;
<#
            }
#>
        }
<#
        }
    }

    if (!string.IsNullOrEmpty(keyType))
    {
        var currentReferenceType = model
            .References
            .FirstOrDefault(r =>
                r.Type == keyType);

        var type =
            currentReferenceType != null
            && currentReferenceType.IsCollection ?
                $"HashSet<{keyType}>" :
                keyType;
#>
        public <#= type #> ConvertToModel()
        {
<#
        var currentReference = model
            .References?
            .FirstOrDefault(r =>
                r.Type == keyType);

        if (currentReference != null
            && !string.IsNullOrEmpty(currentReference.Id))
        {
            var referenceName = currentReference.Id.ToPascalCase();
#>
            return this.<#= referenceName #>;
<#
        }
        else
        {
#>
            var model = new <#= keyType #>();
<#
            if (model.Properties != null)
            {
                foreach (var prop in model.Properties)
                {
                    if (!string.IsNullOrEmpty(prop.ModelProperty))
                    {
                        var modelType =  prop
                            .ModelProperty
                            .Substring(
                                0,
                                prop.ModelProperty.IndexOf("."));

                        if (modelType == keyType)
                        {
                            var propertyName = prop
                                .ModelProperty
                                .Substring(
                                    prop.ModelProperty.IndexOf(".") + 1)
                                .ToPascalCase();
#>
            model.<#= propertyName #> = <#= prop.Id.ToPascalCase() #>;
<#
                        }
                    }
                }
            }
#>
            return model;
<#
        }
#>
        }
<#
    }
#>
    }
}